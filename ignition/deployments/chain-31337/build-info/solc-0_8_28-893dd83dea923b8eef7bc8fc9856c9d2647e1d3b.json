{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-893dd83dea923b8eef7bc8fc9856c9d2647e1d3b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EscrowMarket.sol": "project/contracts/EscrowMarket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EscrowMarket.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.28;\r\n\r\ncontract EscrowMarket {\r\n    error NotAdmin();\r\n    error NotSeller(uint256 id);\r\n    error NotBuyer(uint256 id);\r\n    error WrongState(uint8 expected, uint8 got);\r\n    error ZeroValue();\r\n    error BadPrice();\r\n    error InvalidDeal(uint256 id);\r\n    error NotParticipant(uint256 id);\r\n    error SelfPurchaseNotAllowed(uint256 id);\r\n    error InvalidStateForDispute(uint8 got);\r\n    error NothingToWithdraw();\r\n    error SendFailed();\r\n    error DirectPaymentRejected();\r\n    error Paused();\r\n    error DealFrozen(uint256 id);\r\n    error Banned(address account);\r\n\r\n    enum DealState { Listed, Funded, Shipped, Completed, Cancelled, Disputed }\r\n\r\n    struct Deal {\r\n        uint256 id;\r\n        address seller;\r\n        address buyer;\r\n        uint128 price;\r\n        uint64 createdAt;\r\n        DealState state;\r\n        string title;\r\n    }\r\n\r\n    address public immutable admin;\r\n    uint256 public nextId;\r\n    mapping(uint256 => Deal) public deals;\r\n    mapping(address => uint256) public balances;\r\n\r\n    bool public paused;\r\n    mapping(uint256 => bool) public frozen;\r\n    mapping(address => bool) public banned;\r\n\r\n    event DealListed(\r\n        uint256 indexed id,\r\n        address indexed seller,\r\n        uint128 price,\r\n        string title\r\n    );\r\n    event DealTitleUpdated(uint256 indexed id, string title);\r\n    event DealFunded(uint256 indexed id, address indexed buyer, uint128 amount);\r\n    event DealShipped(uint256 indexed id);\r\n    event DealCompleted(uint256 indexed id);\r\n    event DealCancelled(uint256 indexed id);\r\n    event DealDisputed(uint256 indexed id);\r\n    event DealResolved(uint256 indexed id, bool releasedToSeller);\r\n    event Withdrawal(address indexed account, uint256 amount);\r\n    event DealDelisted(uint256 indexed id);\r\n    event PausedSet(bool paused);\r\n    event DealFrozenSet(uint256 indexed id, bool frozen);\r\n    event BannedSet(address indexed account, bool banned);\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) revert NotAdmin();\r\n        _;\r\n    }\r\n\r\n    modifier onlySeller(uint256 id) {\r\n        Deal storage d = deals[id];\r\n        if (d.seller == address(0)) revert InvalidDeal(id);\r\n        if (msg.sender != d.seller) revert NotSeller(id);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBuyer(uint256 id) {\r\n        Deal storage d = deals[id];\r\n        if (d.seller == address(0)) revert InvalidDeal(id);\r\n        if (msg.sender != d.buyer) revert NotBuyer(id);\r\n        _;\r\n    }\r\n\r\n    modifier inState(uint256 id, DealState expected) {\r\n        Deal storage d = deals[id];\r\n        if (d.seller == address(0)) revert InvalidDeal(id);\r\n        if (d.state != expected) revert WrongState(uint8(expected), uint8(d.state));\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        if (paused) revert Paused();\r\n        _;\r\n    }\r\n\r\n    modifier notFrozen(uint256 id) {\r\n        if (frozen[id]) revert DealFrozen(id);\r\n        _;\r\n    }\r\n\r\n    modifier notBannedForNewDeals() {\r\n        if (banned[msg.sender]) revert Banned(msg.sender);\r\n        _;\r\n    }\r\n    // --- Admin controls --- //Pausning, frysning och förbud\r\n    function pause() external onlyAdmin { paused = true; emit PausedSet(true); }\r\n    function unpause() external onlyAdmin { paused = false; emit PausedSet(false); }\r\n    function freeze(uint256 id) external onlyAdmin {\r\n        if (deals[id].seller == address(0)) revert InvalidDeal(id);\r\n        frozen[id] = true; \r\n        emit DealFrozenSet(id, true);\r\n    }\r\n    function unfreeze(uint256 id) external onlyAdmin {\r\n        if (deals[id].seller == address(0)) revert InvalidDeal(id);\r\n        frozen[id] = false; \r\n        emit DealFrozenSet(id, false);\r\n    }\r\n    function setBanned(address account, bool isBanned) external onlyAdmin {\r\n        banned[account] = isBanned; emit BannedSet(account, isBanned);\r\n    }\r\n        // --- Admin controls --- //Pausning, frysning och förbud  ---end---\r\n\r\n    function list(\r\n        uint128 price,\r\n        string calldata title\r\n    ) external whenNotPaused notBannedForNewDeals returns (uint256 id) {\r\n        if (price == 0) revert ZeroValue();\r\n        unchecked { \r\n            id = ++nextId;\r\n        }\r\n        deals[id] = Deal({\r\n            id:        id,\r\n            seller:    msg.sender,\r\n            buyer:     address(0),\r\n            price:     price,\r\n            createdAt: uint64(block.timestamp),\r\n            state:     DealState.Listed,\r\n            title:     title\r\n        });\r\n        emit DealListed(id, msg.sender, price, title);\r\n    }\r\n\r\n    function updateTitle(\r\n        uint256 id,\r\n        string calldata title\r\n    )\r\n        external\r\n        whenNotPaused\r\n        notFrozen(id)\r\n        onlySeller(id)\r\n        inState(id, DealState.Listed)\r\n    {\r\n        Deal storage d = deals[id];\r\n        d.title = title;\r\n        emit DealTitleUpdated(id, title);\r\n    }\r\n\r\n    function fund(uint256 id)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        notBannedForNewDeals\r\n        notFrozen(id)\r\n        inState(id, DealState.Listed)\r\n    {\r\n        Deal storage d = deals[id];\r\n        if (msg.sender == d.seller) revert SelfPurchaseNotAllowed(id);\r\n        uint128 price = d.price;\r\n        if (msg.value != uint256(price)) revert BadPrice();\r\n        d.buyer = msg.sender;\r\n        d.state = DealState.Funded;\r\n        emit DealFunded(id, msg.sender, price);\r\n    }\r\n\r\n    function ship(uint256 id)\r\n        external\r\n        whenNotPaused\r\n        notFrozen(id)\r\n        onlySeller(id)\r\n        inState(id, DealState.Funded)\r\n    {\r\n        Deal storage d = deals[id];\r\n        d.state = DealState.Shipped;\r\n        emit DealShipped(id);\r\n    }\r\n\r\n    function confirmReceived(uint256 id)\r\n        external\r\n        whenNotPaused\r\n        notFrozen(id)\r\n        onlyBuyer(id)\r\n        inState(id, DealState.Shipped)\r\n    {\r\n        Deal storage d = deals[id];\r\n        balances[d.seller] += uint256(d.price);\r\n        d.state = DealState.Completed;\r\n        assert(d.state == DealState.Completed);\r\n        emit DealCompleted(id);\r\n    }\r\n\r\n    function cancelBeforeShipment(uint256 id)\r\n        external\r\n        whenNotPaused\r\n        notFrozen(id)\r\n        onlyBuyer(id)\r\n        inState(id, DealState.Funded)\r\n    {\r\n        Deal storage d = deals[id];\r\n        balances[d.buyer] += uint256(d.price);\r\n        d.state = DealState.Cancelled;\r\n        emit DealCancelled(id);\r\n    }\r\n\r\n    function deleteList(uint256 id)\r\n        external\r\n        whenNotPaused\r\n        notFrozen(id)\r\n        onlySeller(id)\r\n        inState(id, DealState.Listed)\r\n    {\r\n        delete deals[id];\r\n        emit DealDelisted(id);\r\n    }\r\n\r\n    function openDispute(uint256 id) external whenNotPaused {\r\n        Deal storage d = deals[id];\r\n        if (d.seller == address(0)) revert InvalidDeal(id);\r\n        if (msg.sender != d.seller && msg.sender != d.buyer) {\r\n            revert NotParticipant(id);\r\n        }\r\n        if (d.state != DealState.Funded && d.state != DealState.Shipped) {\r\n            revert InvalidStateForDispute(uint8(d.state));\r\n        }\r\n        d.state = DealState.Disputed;\r\n        emit DealDisputed(id);\r\n    }\r\n\r\n    function resolveDispute(uint256 id, bool releaseToSeller)\r\n        external\r\n        onlyAdmin\r\n        inState(id, DealState.Disputed)\r\n    {\r\n        Deal storage d = deals[id];\r\n        if (releaseToSeller) {\r\n            balances[d.seller] += uint256(d.price);\r\n            d.state = DealState.Completed;\r\n        } else {\r\n            balances[d.buyer] += uint256(d.price);\r\n            d.state = DealState.Cancelled;\r\n        }\r\n        emit DealResolved(id, releaseToSeller);\r\n    }\r\n\r\n    function withdraw() external {\r\n        uint256 amount = balances[msg.sender];\r\n        if (amount == 0) revert NothingToWithdraw();\r\n        require(address(this).balance >= amount);\r\n        balances[msg.sender] = 0;\r\n        (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\r\n        if (!ok) revert SendFailed();\r\n        emit Withdrawal(msg.sender, amount);\r\n    }\r\n\r\n    receive() external payable {\r\n        revert DirectPaymentRejected();\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert DirectPaymentRejected();\r\n    }\r\n}\r\n"
      }
    }
  }
}